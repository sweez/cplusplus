Day 3 Notes & Answers

Page 42-66

Today, you will learn
• How to declare and define variables and constants
• How to assign values to variables and manipulate those values
• How to write the value of a variable to the screen

Note 1
{
	What is a variable? 

	A variable is a place to store information that you can retrieve for later use. 

	Take note that variables are used for temporary storage, so by exiting your program or turning your computer off, the information will be lost into the void to never be seen again.
}

Note 2
{
	Storing data in memory

	Your computer’s memory can be viewed as a series of cubbyholes. Each cubbyhole is one of many, many such holes all lined up. Each cubbyhole—or memory location—is numbered sequentially. These numbers are known as memory addresses. 
	
	A variable reserves one or more cubbyholes in which you can store a value.

	Your variable’s name (for example, myVariable) is a label on one of these cubbyholes so that you can find it easily without knowing its actual memory address.
}

Note 3
{
	Size of integers

	On any one computer, each variable type takes up a single, unchanging amount of room.
	
	That is, an integer might be two bytes on one machine and four on another, but on either computer it is always the same, day in and day out.
	
	Single characters—including letters, numbers, and symbols—are stored in a variable of type char. A char variable is most often one byte long. 

	For smaller integer numbers, a variable can be created using the short type. A short integer is two bytes on most computers, a long integer is usually four bytes, and an integer (without the keyword short or long) is usually two or four bytes.

	The size of an integer is determined by the processor (16 bit, 32 bit, or 64 bit) and the compiler you use. On a 32-bit computer with an Intel Pentium processor, using modern compilers, integers are four bytes. 
}

Note 4
{
	New operator - sizeof(parameter)

	The sizeof operator is used like a function. 
	When called it will tell you the size of the specified item (parameter).
}

Note 5
{
	signed and unsigned

	All integer types are either signed or unsigned.
	
	signed: Negative & Positive
	unsigned: Positive

	If not specified otherwise it will automatically be set as signed.


	Integers will be the same storage size no matter whether you use signed or unsigned

	signed short can store from -32 768 to 32 767
	unsigned short can store from 0 to 65 535
}

Note 6
{
	Variable types

	TYPE 					SIZE 		VALUES
	bool 					1 byte 		true or false
	unsigned short int 		2 bytes 	0 to 65,535
	short int 				2 bytes 	–32,768 to 32,767
	unsigned long int 		4 bytes 	0 to 4,294,967,295
	long int 				4 bytes 	–2,147,483,648 to 2,147,483,647
	int (16 bit) 			2 bytes 	–32,768 to 32,767
	int (32 bit) 			4 bytes 	–2,147,483,648 to 2,147,483,647
	unsigned int (16 bit) 	2 bytes 	0 to 65,535
	unsigned int (32 bit) 	4 bytes 	0 to 4,294,967,295
	char 					1 byte 		256 character values
	float 					4 bytes 	1.2e–38 to 3.4e38
	double 					8 bytes 	2.2e–308 to 1.8e308
}

Note 6
{
	Defining a Variable

	To create/define a variable you have to state its type, followed with one or more spaces, followed by a variable name and a semicolon.

	The variable name can be virtually any combination of letters, but it can not contain any spaces! 
	
	It's also important to note that it's case sensitive! 
	A variable named age is different from Age, which is different from AGE.

	Examples of legal Variable names:
	x, j23qrsnf, and myAge

	Try to keep the variable names short and easy-to-understand though.
	This will help both yourself and anyone else who might take a look at your code to quickly understand what's going on.

	Here's one bad and one good example of naming your variables.

		Example 1
		int main()
		{
		unsigned short x;
		unsigned short y;
		unsigned short z;
		z = x * y;
		return 0;
		}



		Example 2
		int main()
		{
		unsigned short Width;
		unsigned short Length;
		unsigned short Area;
		Area = Width * Length;
		return 0;
		}


	When a variable is declared memory will be allocated (set aside) for it. 
}

Note 7
{
	Naming Conventions

	There's different conventions for how to name variables, though it does not matter too much which method you adopt. 
	The important part is to stay consistent throughout your program.


	Many programmers prefer to use all lowercase letters for their variable names. 
	If the name requires two words (for example, my car), two popular conventions are used: my_car or myCar. 

	The latter form is called camel notation because the capitalization looks something like a camel’s hump.


	List of keywords not allowed to be used in variable names as they have special meaning already.

	asm 			else 		new 				this
	auto 			enum 		operator 			throw
	bool 			explicit 	private 			true
	break 			export 		protected 			try
	case 			extern 		public 				typedef
	catch 			false 		register 			typeid
	char 			float 		reinterpret_cast 	typename
	class 			for 		return 				union
	const 			friend 		short 				unsigned
	const_cast 		goto 		signed 				using
	continue 		if 			sizeof 				virtual
	default 		inline 		static 				void
	delete 			int 		static_cast 		volatile
	do 				long 		struct 				wchar_t
	double 			mutable 	switch 				while
	dynamic_cast 	namespace 	template
	
	In addition, the following words are reserved:
	And 			bitor 		not_eq 				xor
	and_eq 			compl 		or 					xor_eq
	bitand 			not 		or_eq
}

Note 8
{
	DO define a variable by writing the type, then the variable name.
	DO use meaningful variable names.
	DO remember that C++ is case sensitive.
	DO understand the number of bytes each variable type consumes in memory and what values can be stored in variables of that type.


	DON’T use C++ keywords as variable names.
	DON’T make assumptions about how many bytes are used to store a variable.
	DON’T use unsigned variables for negative numbers.
}

Note 9
{
	Creating more than one variable at a time

	You can create more than one variable of the same type in one statement/line by writing the type and then the variable names, separated by commas.

	Examples:
	unsigned int myAge, myWeight; // two unsigned int variables
	long int area, width, length; // three long integers
}

Note 10
{
	Assigning values to your variables

	You can assign a value to a variable using the assignment operator (=).

	unsigned short width;
	width = 5;

	You can combine those two lines into one, making it more compact.

	unsigned short width = 5;


	It's also possible to initialize more than one variable at creation.

	long width = 5, length = 7;
}

Note 11
{
	"long" is a shorthand version of "long int"
	"short" is a shorthand version of "short int"
}

Note 12
{
	Define = You create the variable
	Initialize = You assign a value to the variable
}

Note 13
{
	Creating aliases with typedef

	typedef stands for type definition

	typedef is used to avoid having to repeatedly write a phrase such as "unsigned short int". 

	Basically what it does is creating a synonym.


	Syntax:
	typedef <existing type> <new name>;

	Example: 
	typedef unsigned short int USHORT;
}

Note 14
{
	When to use short and when to use long

	The rule is very straight forward: If any chance exists that the value you'll want to put into your variable will be too big for its type, use a larger type.
}

Note 15
{
	If you wish to go higher than what 'unsigned long integers' can hold then you will have to go to float or double, but at the expense of some precision. 
}

Note 16
{
	Wrapping around an unsigned integer

	When an unsigned integer reaches it maximum value it will wrap around and start over. 
}

Note 17
{
	type char variables are typically 1 byte, enough to hold 256 values.
	A char can be interpreted as a small number (0-255) or as a member of the ASCII set.

	As an example, "a" is assigned the value 97.
}

Note 18
{
	The Escape Characters

	The compiler will recognize some special characters for formatting. 
	
	To put a tab character into your code, you enter a single quotation mark, the slash, the letter t, and then a closing single quotation mark:

	char tabCharacter = ‘\t’;

	The escape character (\) changes the meaning of the character that follows it. As an example, normally the character n means the letter n, but when it is preceded by the escape character, it means new line.

CHARACTER 	WHAT IT MEANS
	\a 		Bell (alert)
	\b 		Backspace
	\f 		Form feed
	\n 		New line
	\r 		Carriage return
	\t 		Tab
	\v 		Vertical tab
	\’ 		Single quote
	\” 		Double quote
	\? 		Question mark
	\\ 		Backslash
	\000 	Octal notation
	\xhhh 	Hexadecimal notation
}

Note 19
{
	Constants

	Like variables, constants are used for storing values.
	Unlike variables, and just as the name implies, constants don't change - they remain constant.
	You must initialize a constant when you create it.


	-- Literal Constants --

	A literal constant is a value typed directly into your program wherever it is needed. 

	Example:
	int myAge = 39;

	//

	-- Symbolic Constants --

	A symbolic Constants is a constant that is represented by a name, just as a variable is represented.
	Unlike a variable, however, after a constant is initialized, its value can not be changed.


	If your program has an integer variable named students and another named classes, you could compute how many students you have, given a known number of classes, if you knew each class consisted of 15 students:

	students = classes * 15;


	In this example, 15 is a literal constant. Your code would be easier to read, and easier to maintain, if you substituted a symbolic constant for this value:
	
	students = classes * studentsPerClass


	The main benefit of using a symbolic constant over a literal constant is that if you later decided to change the number of students in each class, you would just have to change it in one place rather than having to make a change in every place where you placed that value.
}

Note 20
{
	Defining Constants with #define

	NOTE: This methos is obsolete and should no longer be used!!

	Back in the day, when you wanted to define a constant you would do:

	#define studentsPerClass 15

	Because that studentsPerClass is of no particular type (int, char, etc) the preprocessor only sees the number 15.
}

Note 21
{
	Defining Constants with const

	A much better alternative to #define when it comes to define constants.

	const unsigned short int studentsPerClass = 15;

	The example above is declared as a symbolic constant named studentsPerClass, but this type its typed as an unsigned short int.

	This method of declaring constants has several advantages in making your code easier to maintain and in preventing bugs.

	The main difference is that this constant has a type, and the compiler can enforce it accordingly.
}

Note 22
{
	DO watch for numbers overrunning the size of the integer and wrapping around incorrect values.
	DO give your variables meaningful names that reflect their use.

	DON’T use keywords as variable names.
	DON’T use the #define preprocessor directive to declare constants. Use const.
}

Note 23
{
	Enumerated Constants

	The syntax is as follows: 
	enum <NAME> {VALUE1, VALUE2, ETC3};

	Example 1:
	enum COLOR { RED, BLUE, GREEN, WHITE, BLACK };
				  0     1     2      3      4

	I have assigned the values of each color for an easier understanding how it works. 

	Every enumerated constant has an integer value. 
	Unless specified otherwise, the first constant has the value 0, and the rest count up from there. 

	However, any one of the constants can be initialized with a specific value, and those not initialized count upward from the ones before them. Example below.

	Example 2:
	enum Color { RED=100, BLUE, GREEN=500, WHITE, BLACK=700 };
				   100     101	   500      501      700
}




--- Workshop --- 

{	Quiz:

	1. What is the difference between an integer variable and a floating-point variable?
	A: floating-point variables can store fractions while integer variables can not.


	2. What are the differences between an unsigned short int and a long int?
	A: An unsigned short int can only contain positive integers, can store values up to 65 353.
	long int can store values between -2 147 483 648 to 2 147 483 647



	3. What are the advantages of using a symbolic constant rather than a literal constant?
	A: It makes it easier to maintain larger codes as you only have to change the value in one place rather than every place you assigned it to one by one. 

	4. What are the advantages of using the const keyword rather than #define?
	A: #define is obsolete. Using const keyword makes the code easier to maintain and helps prevent bugs to slip in. 
	The main difference is that the constant has a type, and the compiler can enforce it accordingly.


	5. What makes for a good or bad variable name?
	A: Good: A short, descriptive name that clearly states its purpose. 
	Bad: A long, complicated & cryptic name that does not indicate what it's for, forcing the programmer to backtrack.


	6. Given this enum, what is the value of BLUE?
	enum COLOR { WHITE, BLACK = 100, RED, BLUE, GREEN = 300 };
	A: That's simple, 102.


	7. Which of the following variable names are good, which are bad, and which are invalid?
		a. Age 			Good 	+
		b. !ex 			Invalid +
		c. R79J 		Bad 	+
		d. TotalIncome	Good 	+
		e. __Invalid	Invalid - 
}



{	Exercises:
	
	1. What would be the correct variable type in which to store the following information?
		a. Your age
		b. The area of your backyard
		c. The number of stars in the galaxy
		d. The average rainfall for the month of January
	A: 
		a: unsigned short int
		b: unsigned short
		c: unsigned double
		d: unsigned short int


	2. Create good variable names for this information.
	A: 
		a: yourAge
		b: backyardArea
		c: starsInGalaxy
		d: averageRainfall

	3. Declare a constant for pi as 3.14159.
	A: unsigned float constant pi = 3.14159 -
	Correction: const float PI  = 3.14159;

	4. Declare a float variable and initialize it using your pi constant.
	A: float myPi = PI;
}